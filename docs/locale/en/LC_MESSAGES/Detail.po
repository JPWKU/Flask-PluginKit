# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2018, staugur
# This file is distributed under the same license as the Flask-PluginKit
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Flask-PluginKit \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-04-03 18:13+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../Detail.rst:2
msgid "插件概述"
msgstr ""

#: ../../Detail.rst:4
msgid ""
"插件可以是一个本地目录，它应该位于程序plugins目录下，且是一个合法的python包，即：plugins下包含 ``__init__.py``"
" 文件，插件也包含 ``__init__.py`` , 这个文件标识了目录是一个包，同时也标识了这个插件，是核心代码，插件入口。"
msgstr ""

#: ../../Detail.rst:6
msgid ""
"但请注意：插件亦可以是一个第三方包，您可以使用pip安装它，而不必放到程序当前目录！第三方插件的格式也应该同本地目录一般，详细见 `#第三方插件 "
"<#third-party-plugin>`_"
msgstr ""

#: ../../Detail.rst:10
msgid "术语表"
msgstr ""

#: ../../Detail.rst:12
msgid "tep - 模板扩展点"
msgstr ""

#: ../../Detail.rst:13
msgid "hep - 钩子扩展点"
msgstr ""

#: ../../Detail.rst:14
msgid "bep - 蓝图扩展点"
msgstr ""

#: ../../Detail.rst:15
msgid "yep - 样式扩展点"
msgstr ""

#: ../../Detail.rst:16
msgid "dcp - 动态连接点"
msgstr ""

#: ../../Detail.rst:19
msgid "核心代码"
msgstr ""

#: ../../Detail.rst:21
msgid "这里是一个最迷你的代码::"
msgstr ""

#: ../../Detail.rst:54
msgid ""
"这里还有一个完整的例子，包含了Flask-PluginKit的完整功能，`点击查看 <https://github.com/staugur"
"/Flask-PluginKit/tree/master/example/plugins/example>`_"
msgstr ""

#: ../../Detail.rst:57
msgid "代码解析"
msgstr ""

#: ../../Detail.rst:59
msgid "参考上面迷你代码，这是一个插件所需要的最少的代码，包含元数据(__meta__)和插件类(由getPluginClass函数返回)。"
msgstr ""

#: ../../Detail.rst:61
msgid "元数据(__meta__)完整列表::"
msgstr ""

#: ../../Detail.rst:99
msgid "插件类::"
msgstr ""

#: ../../Detail.rst:126
msgid "插件类详解"
msgstr ""

#: ../../Detail.rst:128
msgid ""
"插件类可以是继承自程序的某个基类，run、register_*至少存在一个方能加载为插件，以便于插件类使用程序基类接口，不过你可能需要在 "
"``__init__.py`` 顶处导入::"
msgstr ""

#: ../../Detail.rst:135
msgid "方法: run -> 仅插件加载时运行此方法"
msgstr ""

#: ../../Detail.rst:137
msgid "环境: 非web"
msgstr ""

#: ../../Detail.rst:139
msgid "用法: 普通方法"
msgstr ""

#: ../../Detail.rst:142
msgid "方法: register_tep -> 注册模板扩展点，提供模板文件或HTML代码"
msgstr ""

#: ../../Detail.rst:144 ../../Detail.rst:234
msgid "环境: web请求上下文、模板中使用"
msgstr ""

#: ../../Detail.rst:151 ../../Detail.rst:197
msgid "用法:"
msgstr ""

#: ../../Detail.rst:147
msgid "要求返回字典，格式是: dict(扩展点=HTML字符串或模板文件)"
msgstr ""

#: ../../Detail.rst:148
msgid "以.html .htm结尾即模板文件，模板文件应该在\"插件包/templates\"下"
msgstr ""

#: ../../Detail.rst:149
msgid "非模板文件支持解析HTML代码，不支持jinja2过滤器、函数等"
msgstr ""

#: ../../Detail.rst:150
msgid ""
"建议您在插件templates下新建目录存放html文件，因为flask-"
"pluginkit仅加载插件下templates目录，且不保证模板冲突，新建目录可以避免与其他插件模板文件冲突，导致无法正常引用。"
msgstr ""

#: ../../Detail.rst:151
msgid ""
"支持模板排序，您需要初始化 ``PluginManager`` 时传入 ``stpl=True`` "
"即可支持。register_tep时，格式是:排序数字@模板代码或文件"
msgstr ""
"Support the template sorting, you need to set parameters ``stpl=True`` "
"when initializing ``PluginManager``, when register_tep, the format is: "
"sort the numeric @template code or file"

#: ../../Detail.rst:153 ../../Detail.rst:238
msgid "示例-注册::"
msgstr ""

#: ../../Detail.rst:161 ../../Detail.rst:246
msgid "示例-使用::"
msgstr ""

#: ../../Detail.rst:189
msgid "方法: register_hep -> 注册钩子扩展点，在flask钩子中注册函数"
msgstr ""

#: ../../Detail.rst:191
msgid "环境: web请求上下文、注册到flask钩子"
msgstr ""

#: ../../Detail.rst:194
msgid ""
"要求返回字典，格式是: dict(扩展点=function)，目前支持三种扩展点: "
"before_request_hook、after_request_hook、teardown_request_hook"
msgstr ""

#: ../../Detail.rst:195
msgid "三种扩展点对应的钩子分别是请求前、请求后(返回前)、请求后(返回前，无论是否发生异常)"
msgstr ""

#: ../../Detail.rst:196
msgid "before_reqest_hook还可以拦截请求，设置属性is_before_request_return=True，使用make_response、jsonify等响应函数或Response构造响应类"
msgstr ""

#: ../../Detail.rst:197
msgid ""
"建议您在插件类中单独写一个方法，并传递给扩展点，其中after_request_hook会传入 ``response`` "
"参数，teardown_request_hook会传入 ``exception`` 参数，您扩展点的函数必须支持传入，并可以自行使用。"
msgstr ""

#: ../../Detail.rst:199 ../../Detail.rst:219
msgid "示例::"
msgstr ""

#: ../../Detail.rst:213
msgid "方法: register_bep -> 注册蓝图扩展点，用来注册一个蓝图"
msgstr ""

#: ../../Detail.rst:215
msgid "环境: web请求上下文"
msgstr ""

#: ../../Detail.rst:217
msgid "用法: 注册蓝图，要求返回字典，dict(blueprint=蓝图类, prefix=蓝图挂载点(比如/example))"
msgstr ""

#: ../../Detail.rst:232
msgid "方法: register_yep -> 注册静态扩展点，提供模板所需引入的css样式"
msgstr ""

#: ../../Detail.rst:236
msgid "用法: 要求返回字典，类似于register_tep，格式是: dict(扩展点=CSS文件)，CSS文件应该在\"插件包/static\"目录下。"
msgstr ""

#: ../../Detail.rst:260
msgid "简单存储"
msgstr ""

#: ../../Detail.rst:262
msgid ""
"v1.3.0支持简单存储服务，其配置姑且命名s3，初始化 ``PluginManager`` "
"时传递s3，值为local(本地文件)、redis(需要传递s3_redis参数，即redis_url)，目前仅支持这两种。 "
"不过您也可以自定义存储类，要求是继承自 :class:`~flask_pluginkit.BaseStorage`, 执行 ``storage``"
" 函数时传入 ``sf(继承的类)`` 和 ``args(继承类参数，如果有的话)``。"
msgstr ""

#: ../../Detail.rst:265
msgid "使用简单存储有两种情况，一是在app应用上下文及请求上下文中，二是在程序中独立使用::"
msgstr ""

#: ../../Detail.rst:283
msgid "动态连接点(dcp)"
msgstr ""

#: ../../Detail.rst:285
msgid ""
"动态连接点，动态注册并执行函数将结果返回给模板使用。您可以通过 :func:`flask_pluginkit.push_dcp` "
"推送给标识点一个函数，在模板中通过 ``emit_dcp`` 执行并获取执行结果(即HTML代码)。"
msgstr ""

#: ../../Detail.rst:287
msgid "用法::"
msgstr ""

#: ../../Detail.rst:298
msgid "使用案例::"
msgstr ""

#: ../../Detail.rst:320
msgid "加载逻辑"
msgstr ""

#: ../../Detail.rst:322
msgid ""
"插件加载在程序启动时完成, 加载类是 :class:`~flask_pluginkit.PluginManager`, "
"它的析构函数支持你传递plugins_base(默认程序目录)、plugins_folder(插件所在目录)设置插件绝对路径目录，还支持工厂模式，更多参数参见API文档。"
msgstr ""

#: ../../Detail.rst:325
msgid "流程如下:"
msgstr ""

#: ../../Detail.rst:327
msgid "通过 ``init_app`` 完成实例构造，初始化参数。"
msgstr ""

#: ../../Detail.rst:328
msgid "扫描插件目录，符合插件规则的包将被动态加载。"
msgstr ""

#: ../../Detail.rst:329
msgid ""
"加载插件信息，依次运行 ``run`` -> ``register_tep`` -> ``register_hep`` -> "
"``register_bep`` -> ``register_yep`` 等方法, 写入到所有插件列表。"
msgstr ""

#: ../../Detail.rst:330
msgid "Flask-PluginKit设置支持多模板文件夹、多静态文件夹（插件目录下）。"
msgstr ""

#: ../../Detail.rst:331
msgid ""
"Flask-PluginKit注册全局模板函数 ``emit_tep``、``emit_yep``、``emit_dcp``, "
"分别是渲染模板上下文、CSS上下文、渲染动态连接点。"
msgstr ""

#: ../../Detail.rst:332
msgid "注册所有启用插件的蓝图扩展点BEP。"
msgstr ""

#: ../../Detail.rst:333
msgid "使用before_request等装饰器注册所有启用插件的钩子扩展点。"
msgstr ""

#: ../../Detail.rst:334
msgid ""
"将 ``PluginManager`` 附加到app中，完成加载，可以使用 ``app.extensions['pluginkit']`` 调用 "
"``PluginManager`` 类中方法。"
msgstr ""

#: ../../Detail.rst:338
msgid "Third party plugin"
msgstr ""

#: ../../Detail.rst:340
msgid "第三方插件是指非程序子目录、来自于pip或easy_install等安装的本地模块。"
msgstr ""

#: ../../Detail.rst:342
msgid ""
"第三方插件解放使用，程序可以不用将插件代码放到子目录，只需要使用 `pip install` 安装到本地机器上，然后在 "
"`PluginManager` 初始化时传入 `plugin_packages` 参数即可。"
msgstr ""

#: ../../Detail.rst:344
msgid ""
"这意味着，任何人都可以编写一个包，发布到pypi；使用者写好 `requirements.txt` "
"并安装依赖，在初始化中调用，一气呵成，而几乎不用担心后续第三方插件升级。"
msgstr ""

#: ../../Detail.rst:348
msgid "如何编写第三方插件："
msgstr ""

#: ../../Detail.rst:350
msgid ""
"首先根据上方 `代码解析 <#id12>`_ 和 `插件类详解 <#id13>`_ 写一个包，参见 `核心代码 <#id10>`_ ，要写在 "
"`__init__.py` 中。"
msgstr ""

#: ../../Detail.rst:353
msgid "第一步中实际上就是编写本地插件的过程，本步骤需要编写 `setup.py` ，使本地插件能发布到pypi中供其他人使用::"
msgstr ""

#: ../../Detail.rst:363
msgid "如果你的插件包含模板目录templates或静态目录static等，需要再编写一个额外的清单文件 `MANIFEST.in`::"
msgstr ""

#: ../../Detail.rst:368
msgid "测试发布"
msgstr ""

#: ../../Detail.rst:370
msgid "4.1 打包：python setup.py sdist bdist_wheel   #更多参数自行调整"
msgstr ""

#: ../../Detail.rst:372
msgid "4.2 到这里，可以使用 `pip install .` 在本地测试是否正常安装。"
msgstr ""

#: ../../Detail.rst:374
msgid ""
"4.3 本地测试通过，可以发布到test.pypi.org，这是官方pypi的测试站，里面的包不会被轻易使用，命令是： `twine upload"
" --repository-url https://test.pypi.org/legacy/ dist/*`"
msgstr ""

#: ../../Detail.rst:376
msgid "4.4 测试站可以看看界面描述等等是否符合心中要求，没问题就发布到正式站，pypi.org，命令是： `twine upload dist/*`"
msgstr ""

#: ../../Detail.rst:379
msgid "示例"
msgstr ""

#: ../../Detail.rst:379
msgid ""
"`pypi demo <https://github.com/staugur/Flask-"
"PluginKit/tree/master/example/plugins/example/pypi>`_"
msgstr ""

#~ msgid ""
#~ "插件是一个本地目录，它应该位于程序plugins目录下，且是一个合法的python包，即：plugins下包含 "
#~ "``__init__.py`` 文件，插件也包含 ``__init__.py`` , "
#~ "这个文件标识了目录是一个包，同时也标识了这个插件，是核心代码，插件入口。"
#~ msgstr ""

